# -*- mode: org; coding: utf-8; -*-
#+TITLE: Title Template for Degree Project
#+SUBTITLE: SUBTITLE - Arial 16/19pt
#+AUTHOR: Therese Kennerberg, Teo Klestrup Röijezon
# Fancy code blocks
#+LATEX_HEADER: \usepackage{mdframed}
#+LATEX_HEADER: \usepackage{minted}
#+LATEX_HEADER: \setminted{linenos}
#+LATEX_HEADER: \surroundwithmdframed{minted}
# Include SVG graphics
#+LATEX_HEADER: \usepackage{svg}
# LaTeX export results in jumbled text scaling
#+LATEX_HEADER: \svgsetup{inkscapelatex=false,inkscapearea=page}
# Fancy links
#+LATEX_HEADER: \usepackage{xcolor}
#+LATEX_HEADER: \hypersetup{colorlinks, linkcolor={red!50!black}, citecolor={blue!50!black}, urlcolor={blue!80!black}}
# Set up citation system
#+LATEX_HEADER: \usepackage{biblatex}
#+LATEX_HEADER: \addbibresource{piconodes.bib}
#+BEGIN_SRC emacs-lisp :results silent :exports results
  (setq org-latex-pdf-process '("latexmk -shell-escape -bibtex -pdf %f")
        org-latex-listings 'minted
        org-ditaa-jar-path "lib/ditaa-0.11.0-standalone.jar"
        org-plantuml-jar-path "lib/plantuml.1.2018.3.jar"
        org-latex-default-figure-position "tbp")
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((ditaa . t)
     (plantuml . t)))
#+END_SRC

* Introduction

The goal of this project outcome is to provide a hands-on physical
pedagogical education platform for schools. The platform will be
tailored towards Skolverket's new cirriculum and learning goals for the subjects Computational
Thinking and Programming\cite{KTek2017} (which will take effect from Juli 2018). The
platform is aimed towards teaching parallel programming and distributed systems using a
custom assembler-like language.

** Delimitations

The project is limited to 2.5 months, so the product will not be ready for the market in this time. Rather, the
project aims to build up a ground for a future product that can be represented on the market. It will be a simple
prototype, primarily so that the students can try it out.

Further development and improvment will be mentioned in Chapter [[#further_opportunities]].

The product will be targeted towards students in eighth grade, both students who have programmed before and students
who are new to it.

* Background

The digitalization of our society is moving quickly, and we all want to keep up with it. This puts a lot of pressure on the schools
to teach programming and computational thinking in the education. For this reason Skolverket is adding computational thinking
# Better word than elementary?
to the elementary school curriculum.

# Source for this claim
Several countries have implemented programming into their schools, and this is creating market demand for tools to
use in the teaching process. Many products to help teach this subject already exist, but they are generally all focused
on providing a simple environment for programming a single isolated computer. This is great, but we believe it's just
as important to understand how multiple computers interact in networks, as well as how low-level assembler programming
works.

** TODO Terminology

** Computational thinking in Swedish schools

Skolverket is adopting programming and computational thinking in schools and has set up goals for the schools to implement.

Computational thinking is stated by Linköping's University to be a process of problem-solving which includes:

- Formulating a problem in such a way that it becomes possible to use computers to solve it.
- Breaking down complex problems into smaller parts.
- Finding repeating patterns and reusing them.
- Creating algorithms to automate the solution of a problem.
- Logically organizing and analyzing data.
- Represent data through abstractions such as models and simulations.
- Identifying, analyzing, and implementing possible solutions to find the most
  effective one.
- To generalize and use this kind of problem-solving process on other
  kinds of problems.

According to Heintz and Mannila\cite{HeintzMannila}, computing in schools should
have three key stages:

1. Ages 5-6: algorithms and instructions, to create and debug simple
   programs, with a focus on logical thinking.
2. Ages 7-11: Develop and debug greater problems
   with given goals and use programming concept with variables, sequences,
   selection and repetition.
3. Ages 12-14: Two or more programming languages, Boolean logic, binary numbers,
   connection between the program and hardware.

This project is directed to be used by student in the ages of 14-15, fitting the
last key stage quite well.

One important thing to consider in the process of teaching computational thinking
and programming is to have very clear guidance and considerations for the teachers,
who need to understand the learning concept fully to be able to teach it.

# Find the primary source or scrap

A study made in 2017 by Lararnas Riksforbund show that 8 of 10 mathteachers with student in 8:th and 9:th grade 
feels insecure about teaching programming and 54% of the teachers don't 
have any experince in programming at all.
# Lararnas riksforbund, letar kalla..

Another challange the teachers are anxious to develop new learning resources, and feel insecure
in dealing with new and unfamiliar teaching material.\Cite{Bower17} For this reasons the project
will keep the teachers, and how to prepare them to use the tools the platform provides, in mind.
The UI will be as simple as possible, so that it is easy to use with few steps to set-up, so that
they can focus on the programming.

*** Prior Art

So far, "educational" programming has mostly taken one of two tracks: "toy" languages and environments

that are designed to be visually exciting (such as Scratch\cite{Scratch}), or disposable limited computers
(see Raspberry Pi\cite{RaspberryPi} and BBC micro:bit\cite{MicroBit}).

We've tried to go in a slightly different route, inspired by Zachtronics Industries' games Shenzhen
I/O\cite{ShenzhenIO} and TIS-100\cite{TIS100}. Instead of giving them a single computer or microcontroller
for the whole project, we give them a whole bunch of /extremely/ limited microcontrollers, in order to force
them to think about splitting their projects long before a traditional approach does. To compensate for this,
we've also provided a simplified way to communicate between them, without having to worry about more complicated
concerns, such as bits, timing, and clock skew.

To differentiate from the Zachtronics games we've actually built a physical kit using these principles,
rather than just providing the user with a simulator.

** Research Questions

The study has examined the following questions:

1. How to implement the new outcomes for computational thinking presented by Skolverket.
2. Implementation of a platform to teach tha basics of bare metal programming to students.
3. Evaluation of the pedagogical usefulness of the platform and how to implement
   the idea to motivate students.

** Purpose

Improving the digital literacy of school students, in Sweden and abroad.

** Goal

The goal with the project is to develop a basic prototype of a educational platform to be used in the Swedish scools.

** Ethics and Sustainability

It's important to make sure that the product is produced in a sustainable manner. For example, care should be taken to avoid
conflict minerals, child labour, and so on.

It should also be secure enough that it can't be snooped on, or abused by malware and botnets. Currently all traffic between
the downloaders and the server is encrypted and authenticated, and reasonable care has been taken to ensure that the
communication is handled safely. However, the security has not been professionally audited, and it has been designed
under the assumption that it will be used in an isolated network.

The server also doesn't currently authenticate users.

Finally, as an educational product we believe that it's very important that the students have the freedom to tinker with it freely,
and that they have access to all the design materials. Any educational product is ultimately about setting up "illusions" so that
the user can focus on what's important, but it's just as vital that they are allowed to peek behind the curtain once they feel
ready.

* Method

# State the problem and underlying assumption.

Skolverket is about to implement new learning goals for computational thinking in Juli 2018. Their vision for
2020 is that every student has developed an adequate competence for digital technology
https://liu.se/cetis/konferenser/documents-tis2017/m2-3-datalogiskt-tankande.pdf).
# Try to find primary source?

The primary question for this thesis project is: "How can you implement computational thinking
for an parallel and hardware-close programming?". To try to answer this we developed a platform to
be used in schools when teaching programming. The evaluation of the platform was based on letting
school students and teachers play around with a prototype, and then letting them fill out a questionnaire
about their experience.

The question formulation in this thesis report is how can you implement computational thinking
For the project, a platform was developed to
be used as a tool in the schools education when teaching programming and was iterative developed
during the last 3 weeks of the project from evaluation research. The evaluation of the platform was based on research
with questionnaires to the the teachers and students and feedback after they checked out the products
prototypes. The questionnaire is formed so the answers can give us a foundations for developing a
pedagogical and motivating tool the student can use to achieve the outcomes for computational thinking.

** Targeted user and scool selection

The product is directed to student in 8:th grade. The platform is aiming to be a good base for students without programming practise as well to be challenging enough
on a higher level for a more experienced programmer. The manual is in english so the students must understand english well.
Initially we wanted to feedback from as diverse a set of schools as possible but because of the lack of interest from the scools, only one
volunteered to evaluate the prototype. To try to gather as much data as possible, family members was asked to participate for the avaluation of the prototype.

** Evaluation

Questioniars is used to get an evaluation from the students testing the prototype.

The data are gathered by questionairs with two sections. One section is about their experience in generall with encounter programming and
section two is about thier experince with the prototype. This is to evaluate what disposition the students can have about programming and
if we change that disposition. The teachers and student are handed  a similar questionair but with straighten questions towards the use of the product
teaching/learning.
# should we have the questions in the report?
The data will be used to evaluate the product and for suggestions to future work.

** Specific research tools and strategies

The product will have the UI designed in the browser so the user wont be fixed to one platform. This way
either a mobile phone or a laptop can be used for programming the micro-controllers. The MCU of our choice
is stm32f030f4p6. This MCU is chosen because it got enough I/Os and memory space for the application and
is reasonable cheep. This MCUs are also popular to program in Rust which make it easier to find documentation
and support. At least 8 I/O is needed. UART communication(two pins for TX and RX), communications between
the MCUs(4 pins), external clock source and coarse grained syncronization clock. A server will be provided
by Inicio which contains the drivers for communicating between the platforms and the compiler for the bytecode.

** Programming Langueges

Rust is used to program the MCU. The MCU of our choice is
stm32f030f4p6. C is also an option and can be prefered
if anyone would like to use IDE such as EWARM or STM32Cube to generate
initiallisation code but this IDE is not suported by Linux and is why we are using Rust. Rust is also better from a safety
perspective because it is harder to read something from more then one thread
and it verifies pointers are still alive when they are used so you will not be
able to keep a pointer beyond their objects lifetime. Rust also suits very well
with our Bytecode model since our abstract sytax tree contains different legal
values depending on the instruction. Alot of different IDE can be used for Rust,
in this project we will use Emacs because both Scala program and the report is
written here.

The homepage is programmed in Scala. Scala is very practical for not changing
languege when writing the client and server. This makes it easier when communicating
between the server and client.

** CAD and CAM tools

In the first stages of the project it is prefered to be more flexible for changes.
For this reason a breadboard and jumpingwires are used to test the design before
making the final one. The MCU-moduels is made in a routermill so a breakout board
can be made for the MCU pins to match the breadboard.

* Result

** Communication
   :PROPERTIES:
   :CUSTOM_ID: comm
   :END:

We decided to use a mesh interconnect (see Figure [[fig:mesh-grid]]), where each node is connected
to its direct neighbors. This is relatively simple to route, has no chance of collisions, and
# Explain absolute vs relative addressing in background?
requires no form of absolute addressing.

#+BEGIN_SRC ditaa :file Report-comm-layout.svg :cmdline --svg
  +-------------*-------------+        +-------------*-------------+        +-------------*-------------+
  |             Up            |        |             Up            |        |             Up            |
  |                           |        |                           |        |                           |
  |       **PicoNode 1**      |        |       **PicoNode 2**      |        |       **PicoNode 3**      |
  *Left                  Right*<------>*Left                  Right*<------>*Left                  Right*
  |                           |        |                           |        |                           |
  |                           |        |                           |        |                           |
  |            Down           |        |            Down           |        |            Down           |
  +-------------*-------------+        +-------------*-------------+        +-------------*-------------+
                ^                                    ^                                    ^
                |                                    |                                    |
                |                                    |                                    |
                |                                    |                                    |
                v                                    v                                    v
  +-------------*-------------+        +-------------*-------------+        +-------------*-------------+
  |             Up            |        |             Up            |        |             Up            |
  |                           |        |                           |        |                           |
  |       **PicoNode 4**      |        |       **PicoNode 5**      |        |       **PicoNode 6**      |
  *Left                  Right*<------>*Left                  Right*<------>*Left                  Right*
  |                           |        |                           |        |                           |
  |                           |        |                           |        |                           |
  |            Down           |        |            Down           |        |            Down           |
  +-------------*-------------+        +-------------*-------------+        +-------------*-------------+
                ^                                    ^                                    ^
                |                                    |                                    |
                |                                    |                                    |
                |                                    |                                    |
                v                                    v                                    v
  +-------------*-------------+        +-------------*-------------+        +-------------*-------------+
  |             Up            |        |             Up            |        |             Up            |
  |                           |        |                           |        |                           |
  |       **PicoNode 7**      |        |       **PicoNode 8**      |        |       **PicoNode 9**      |
  *Left                  Right*<------>*Left                  Right*<------>*Left                  Right*
  |                           |        |                           |        |                           |
  |                           |        |                           |        |                           |
  |            Down           |        |            Down           |        |            Down           |
  +-------------*-------------+        +-------------*-------------+        +-------------*-------------+
#+END_SRC

#+CAPTION: The PicoNode 2D mesh layout
#+LABEL: fig:mesh-grid
#+RESULTS:
[[file:Report-comm-layout.svg]]

*** PicoTalk
    :PROPERTIES:
    :CUSTOM_ID: picotalk
    :END:

The Nodes communicate using a custom asynchronous single-wire protocol called PicoTalk. We did this because we wanted to use a
mesh interconnect instead of a shared bus, and because we didn't have the hardware support or pin count to connect each pair
using a more common protocol, such as UART. It is /not/ a master/slave protocol, the transmitter/receiver roles are negotiated
for each message.

Because it is asynchronous, each side must provide its own clock. The clocks must be calibrated to 10kHz. The clocks are also
reset for each message, in order to avoid clock skew corruption.

The communication line is held high while idle by a 4.7KΩ pull-up resistor on the motherboard. Thus all participants should be configured in
open drain mode, with their internal pull-ups disabled.

PicoTalk can be divided into four primary stages, as shown in Figure [[fig:picotalk-diagram]]: Idle, Handshake, Preamble, and Message.

In the Idle stage neither party is trying to transmit anything. When a party wants to transmit they enter the Handshake stage,
by transmitting two low ticks. They then wait for a single low tick in response. If no response is heard after three ticks then
the transmitter restarts the Handshake stage. The preamble stage is 5 ticks of alternating high and low signals. This is used to
ensure that the clocks are calibrated correctly. Afterwards the message (a single byte) is sent, least significant bit first.
The bus then returns to the Idle stage.

  #+BEGIN_SRC plantuml :file Report-PicoTalk-timing.svg
    concise "Status" as Status
    concise "Transmitter" as TX
    concise "Receiver" as RX

    Status is Idle
    TX is 1
    RX is 1

    @0

    @+1
    Status is "Failing handshake (no RX)"
    TX is 0

    @+2
    TX is 1

    @+3
    Status is Handshake
    TX is 0

    @+2
    TX is 1

    @+1
    RX is 0

    @+1
    Status is "Waiting for Preamble"
    RX is 1

    @+2
    Status is Preamble
    TX is 1

    @+1
    TX is 0

    @+1
    TX is 1

    @+1
    TX is 0

    @+1
    TX is 1

    @+1
    Status is Message
    TX is "M[0]"
    @+1
    TX is "M[1]"
    @+1
    TX is "M[2]"
    @+1
    TX is "M[3]"
    @+1
    TX is "M[4]"
    @+1
    TX is "M[5]"
    @+1
    TX is "M[6]"
    @+1
    TX is "M[7]"

    @+1
    Status is Idle
    TX is 1
  #+END_SRC

  #+CAPTION: The stages of PicoTalk
  #+NAME: fig:picotalk-diagram
  #+RESULTS:
  [[file:Report-PicoTalk-timing.svg]]

** Node Design

There are a few design elements that are common to all nodes, to ensure that they can all be placed in any position
on the motherboard, and so that they can all be debugged using the same tools.

Using the LED node (Figure [[fig:led-node-pcb-front]]) as an example, they all share the following features:

#+CAPTION: The front side of the LED Node PCB
#+LABEL: fig:led-node-pcb-front
#+ATTR_LATEX: :width 4cm
[[./led-node-pcb-front.png]]

- They are all 30.48x27.94mm
- The angled corner marks the correct orientation
- The grips (in the top and bottom) help you to remove the nodes from a packed motherboard
- The pins all follow this layout (from left to right):
  - Top row:
    - 3.3V power (VDD)
    - SWCLK (used for debugging only, normally NC)
    - Ground
    - SWDIO (used for debugging only, normally NC)
    - Reset (active low)
  - Bottom row:
    - Down
    - Left
    - Up
    - Right
- They are all powered by STM32F030F4P6 MCUs

** Nodes

We designed and fabricated three different Nodes: a LED display Node (see Figure [[fig:led-node-pcb-front]]), a button
input Node (see Figure [[fig:button-node-pcb-front]]), and a programmable compute Node (see Figure
[[fig:compute-node-pcb-front]]) to connect them. They are documented further in their respective appendices (see Appendix
[[#appendix-piconode-led]], [[#appendix-piconode-switch]], and [[#appendix-piconode-compute]], respectively).

# Bring them inline instead?

#+CAPTION: The front side of the button Node PCB
#+LABEL: fig:button-node-pcb-front
#+ATTR_LATEX: :width 4cm
[[./button-node-pcb-front.png]]

#+CAPTION: The front side of the compute Node PCB (the RX/TX pins are supposed to be female, but limited by the CAD software)
#+LABEL: fig:compute-node-pcb-front
#+ATTR_LATEX: :width 4cm
[[./compute-node-pcb-front.png]]

** Motherboard

We designed a motherboard based on the [[#comm][communication layout]] mentioned earlier, visualized in Figure [[fig:motherboard-pcb-front]].
It also provides power, ground, and a reset control to all the nodes.

#+CAPTION: The front side of the motherboard PCB (female connectors are not shown due to CAD software limitations)
#+LABEL: fig:motherboard-pcb-front
[[./motherboard-pcb-front.png]]

** PicoASM

We designed a simple assembler dialect, based on Shenzhen I/O's assembler language\cite{ShenzhenIO}. It is documented
in further detail in Appendix [[#appendix-piconode-compute]]. Contrary to typical x86 desktop processors it does not have
any jump or branch instructions. Instead any instruction can be associated with a conditional flag, which is set by
our test instructions. An example PicoASM program is given in Listing [[lst:picoasm-prng]], which acts as a simple "wheel
of fortune", given a Button Node on the left side, and a LED Node on the right side.

#+CAPTION: An example PicoASM program: a "wheel of fortune" that spins while an input greater than zero is given
#+LABEL: lst:picoasm-prng
#+BEGIN_SRC text
  tcp left 0
+ mov acc right
+ teq acc 4
+ mov 1 acc
- add 1
#+END_SRC

** PicoIDE

We provided a web-based editor called PicoIDE, which allows you to edit programs and upload them to Compute nodes. It
be seen in Figure [[fig:picoide-screenshot]]. It is intended that this runs on a server on the same network as the
Downloaders.

#+CAPTION: A screenshot of PicoIDE, with a few saved files and showing the program in Listing [[lst:picoasm-prng]]
#+LABEL: fig:picoide-screenshot
[[./picoide-screenshot.png]]

*** Security

Downloaders communication is encrypted using TLS, with verification of client and server certificates. Browser
communication is not encrypted by default, but it is recommended that this is done using a reverse proxy, such
as Nginx. There is currently no user authentication system.

* Analysis

Eftersom en prototyp hann sammanställas så kunde en analys göras av hur studenter i årskurs 8 göras tillsammans med deras lärare.
På grund av bristande intresse och dåligt med tid kunde vi endast få en skola att göra en utvärdering samt några släktingar. Resultatet var bättre än väntat, 
7 av 8 elever och läraren fann PicoNode conceptet enkelt att förstå eller pedagogiskt, en elev tyckte att konceptet var rörigt.
Ingen elev fann våra intruktioner svåra att följa och det visuellla upplägget var tydligt. 6 elever blev motiverade att programmera med PicoNodes och två hade ingen 
uppfattning. Alla eleverna hade stött på programmering tidigare och i skolan hade dom jobbat lite med JavaScript. 6 elever fann det medelsvårt med att lära sig programmera 
och två tyckte att det var enkelt.

To get scools to help us evaluate the prototype has ben challenging, even though we were well in time, half a year in advanced, with requests.
This has made us short of data to evaluate and only some observations of how the students interact with our product. The feedback we got was better then 
expected, most of the students got motiveted to program with PicoNodes. 

One of the challanges was to define the functions of the nodes. Some nodes needed to be programmable but to be able to visualize the program written by the user, 
"action" nodes was needed. To define the nodes with more specific funcionallity, a seperation between the actionnodes and programmable nodes was made. One switchnode, 
one lednode and 8 computenode was developed. This mean some restrictions in the placement of the nodes on the motherboard. A try was also done to develop a third 
kind of node to display all the values possible in the communication between the nodes. The node was a lixiedisplay but the light did not hit the numbers enough. 
Is was very doable but would have taken to much time from the critical parts of the project. The lednode was used instead of visulazing the value transmitted but 
limited to four values.

Another problem was that we run out of memory for debugging the program on the nodes. The program that run on the nodes in the endproduct was ok but all the debugging 
tools during the development needed more space. So to keep down the work, a testnode was developed in the same serie of microcontrollers and used for debugging.   

* Further Opportunities
  :PROPERTIES:
  :CUSTOM_ID: further_opportunities
  :END:

#+LATEX: \appendix

* PicoNode-Compute manual
  :PROPERTIES:
  :CUSTOM_ID: appendix-piconode-compute
  :END:

FIXME

* PicoNode-Switch manual
  :PROPERTIES:
  :CUSTOM_ID: appendix-piconode-switch
  :END:

FIXME

* PicoNode-LED manual
  :PROPERTIES:
  :CUSTOM_ID: appendix-piconode-led
  :END:

FIXME

\printbibliography
