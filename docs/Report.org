# -*- mode: org; coding: utf-8; -*-
#+TITLE: A Physical Platform For Teaching Distributed Systems In A Simplified Setting
#+AUTHOR: Therese Kennerberg, Teo Klestrup Röijezon
# Fancy math!
#+LATEX_HEADER: \usepackage{siunitx}
# Fancy acronyms
#+LATEX_HEADER: \usepackage{acronym}
# Fancy code blocks
#+LATEX_HEADER: \usepackage{mdframed}
#+LATEX_HEADER: \usepackage{minted}
#+LATEX_HEADER: \setminted{linenos}
#+LATEX_HEADER: \surroundwithmdframed{minted}
#+LATEX_HEADER: \surroundwithmdframed{quote}
# Include SVG graphics
#+LATEX_HEADER: \usepackage{svg}
# LaTeX export results in jumbled text scaling
#+LATEX_HEADER: \svgsetup{inkscapelatex=false,inkscapearea=page}
# Fancy links
#+LATEX_HEADER: \usepackage{xcolor}
#+LATEX_HEADER: \hypersetup{colorlinks, linkcolor={red!50!black}, citecolor={blue!50!black}, urlcolor={blue!80!black}}
# Set up citation system
#+LATEX_HEADER: \usepackage{biblatex}
#+LATEX_HEADER: \addbibresource{piconodes.bib}
#+BEGIN_SRC emacs-lisp :results silent :exports results
  (setq org-latex-pdf-process '("latexmk -shell-escape -bibtex -pdf %f")
        org-latex-listings 'minted
        org-ditaa-jar-path "lib/ditaa-0.11.0-standalone.jar"
        org-plantuml-jar-path "lib/plantuml.1.2018.3.jar"
        org-latex-default-figure-position "tbp")
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((ditaa . t)
     (plantuml . t)))
#+END_SRC

* Introduction

The goal of this project outcome is to provide a hands-on physical
pedagogical education platform for schools. The platform will be
tailored towards \ac{Skolverket}'s new curriculum and learning goals for the subjects Computational
Thinking and Programming\cite{KTek2017} (which will take effect from July 2018\cite{HesslingPaues17}). The
platform is aimed towards teaching parallel programming and distributed systems using a
custom assembler language.

** Research Questions
   :PROPERTIES:
   :CUSTOM_ID: questions
   :END:

The study has examined the following questions:

1. Implementation of a platform to teach the basics of bare metal programming to students.
2. Evaluation of the pedagogical usefulness of the platform and how to implement
   the idea to motivate students.

** Delimitations

The project is limited to 2.5 months, so the product will not be ready for the market in this time. Rather, the
project aims to build up a solid base for a future project that can be represented on the market. It will be a simple
prototype, primarily so that the students can try it out. Some suggestions for further development opportunities are
mentioned in Chapter [[#further_opportunities]].

The product is targeted towards students in eighth grade, and the goal is for it to be accessible to both students
who have programmed before, and those who have not.

Because of the limited time frame we have not undergone compliance testing (such as for \ac{RF} emissions and \ac{EMC}), which
would be another prerequisite for commercialization.

* Background

The digitalization of our society is moving quickly, and we all want to keep up with it. This puts a lot of pressure on the schools
to teach programming and computational thinking in the education. For this reason \ac{Skolverket} is adding computational thinking
to the Swedish primary school curriculum.

# Source for this claim
Several countries have implemented programming into their schools, and this is creating market demand for tools to
use in the teaching process. Many products to help teach this subject already exist, but they are generally all focused
on providing a simple environment for programming a single isolated computer. This is great, but we believe it's just
as important to understand how multiple computers interact in networks, as well as how low-level assembler programming
works.

** Terminology and Acronyms

#+BEGIN_acronym
\acro{BOM}{Bill of Materials}
\acro{CAD}{Computer-Assisted Design}
\acro{CAM}{Computer-Assisted Manufacturing}
\acro{EMC}{Electromagnetic Compatibility}
\acro{IDE}{Integrated Development Environment}
\acro{IO}[I/O]{Input/Output}
\acro{LED}{Light-Emitting Diode}
\acro{MCU}{Micro-controller Unit}
\acro{PCB}{Printed Circuit Board}
\acro{RF}{Radio Frequency}
\acro{RTFM}{Real-Time For the Masses}
\acro{Skolverket}{The Swedish agency of education}
\acro{USB}{Universal Serial Bus}
#+END_acronym

** Computational thinking in Swedish schools

\ac{Skolverket} is adopting programming and computational thinking in schools and has set up goals for the schools to implement.

Computational thinking is stated by Linköping's University\cite{HeintzMannila}, to be a process of problem-solving which includes:

- Formulating a problem in such a way that it becomes possible to use computers to solve it.
- Breaking down complex problems into smaller parts.
- Finding repeating patterns and reusing them.
- Creating algorithms to automate the solution of a problem.
- Logically organizing and analyzing data.
- Represent data through abstractions such as models and simulations.
- Identifying, analyzing, and implementing possible solutions to find the most
  effective one.
- To generalize and use this kind of problem-solving process on other
  kinds of problems.

According to Heintz and Mannila\cite{HeintzMannila}, teaching computation in schools should
have three key stages:

#+BEGIN_quote
1. Ages 5-6: Algorithms and instructions, to create and debug simple
   programs, with a focus on logical thinking.
2. Ages 7-11: Develop and debug greater problems
   with given goals and use programming concept with variables, sequences,
   selection and repetition.
3. Ages 12-14: Two or more programming languages, Boolean logic, binary numbers,
   connection between the program and hardware.
#+END_quote

This project is aimed at students aged 14-15, and fits the last key stage quite well.

It's also important to consider the teachers. A study made in 2017 by Lärarnas Riksförbund\cite{Larsson17}
shows that 8 of 10 math teachers with students in the 8:th and 9:th grades feel insecure about teaching
programming, and that 54% of the teachers don't have any programming experience at all. According to
another study at Macquarie University\cite{Bower17} teachers tend to be anxious to develop new learning
resources, and especially when dealing with new and unfamiliar teaching material. This shows that the
tools must also be easy to pick up by inexperienced teachers, requiring a heavy focus on good and clear
documentation.

The UI should be kept as simple as possible, so that it is easy to use with few setup steps, letting
them focus on the important part: the programming.

*** Prior Art

So far, "educational" programming has mostly taken one of two tracks: "toy" languages and environments
that are designed to be visually exciting (such as Scratch\cite{Scratch}), or disposable limited computers
(see Raspberry Pi\cite{RaspberryPi} and BBC micro:bit\cite{MicroBit}).

We've tried to go in a slightly different route, inspired by Zachtronics Industries' games Shenzhen
I/O\cite{ShenzhenIO} and TIS-100\cite{TIS100}. Instead of giving them a single computer or \ac{MCU}
for the whole project, we give them a whole bunch of /extremely/ limited \acp{MCU}, in order to force
them to think about splitting their projects a long time before a traditional approach would have. To
compensate for this, we've also provided a simplified way to communicate between them, without having
to worry about more complicated concerns, such as bits, timing, and clock skew.

Compared to the Zachtronics games, building this as a physical kit required us to consider practicality
to a bigger degree. Shenzhen I/O's free-form \ac{PCB} layout system gives the user an extra degree of freedom,
but requiring the user to wait for (and pay for) the \acp{PCB} to be re-manufactured after each design
change would have been very stifling. Alternately, you could have a pre-manufactured \ac{PCB} but let
the user set up connections as they pleased, using jumper wires. However, we also rejected this design
due to space constraints and the messy design it would have produced.

** Purpose

Improving the digital literacy of school students, in Sweden and abroad.

** Goal

To develop a basic prototype of a educational platform to be used in the Swedish schools.

** Ethics and Sustainability

It's important to make sure that the product is produced in a sustainable manner. For example, care should be taken to avoid
conflict minerals, child labor, and so on.

It should also be secure enough that it can't be snooped on, or abused by malware and botnets. Currently all traffic between
the downloaders and the server is encrypted and authenticated, and reasonable care has been taken to ensure that the
communication is handled safely. However, the security has not been professionally audited, and it has been designed
under the assumption that it will be used in an isolated network.

The server also doesn't currently authenticate users.

Finally, as an educational product we believe that it's very important that the students have the freedom to tinker with it,
and that they have access to all the design materials. Any educational product is ultimately about setting up "illusions"
so that the user can focus on what's important, but it's just as vital that they are allowed to peek behind the curtain once
they feel ready.

* Method

# State the problem and underlying assumption.

\ac{Skolverket} is about to implement new learning goals for computational thinking in July 2018. Their vision for
2020 is that every student has developed an adequate competence for digital technology
https://liu.se/cetis/konferenser/documents-tis2017/m2-3-datalogiskt-tankande.pdf).
# Try to find primary source?

The primary question for this thesis project is: "How can you implement computational thinking
for an parallel and hardware-close programming?". To try to answer this we developed a platform to
be used in schools when teaching programming. The evaluation of the platform was based on letting
school students and teachers play around with a prototype, and then letting them fill out a questionnaire
about their experience.

** Targeted user and school selection

The product is directed to students in 8:th grade. The platform is aiming to be a good base for students without programming practice as well to be challenging enough
on a higher level for a more experienced programmer. The manual is in English so the students must understand English well.
Initially we wanted to feedback from as diverse a set of schools as possible but because of the lack of interest from the schools, only one
volunteered to evaluate the prototype. To try to gather as much data as possible, family members was asked to participate for the evaluation of the prototype.

** Evaluation

We used a questionnaire to get an evaluation from the students testing the prototype.

The data are gathered by questionnaires with two sections. One section is about their experience in general with encounter programming and
section two is about their experience with the prototype. This is to evaluate what disposition the students can have about programming and
if we change that disposition. The teachers and student are handed  a similar questionnaire but with straighten questions towards the use of the product
teaching/learning.
# should we have the questions in the report?
The data will be used to evaluate the product and for suggestions to future work.

** Tools

*** Micro-controllers

We chose to base our system around STMicrolectronics' STM32F030\cite{stm32f030} series of micro-controllers. We made
this choice because it was contains both the very cheap F4P6 chip, as well as the beefier but compatible C8T6 which
we used for debugging our software. The whole series also offered enough peripherals for our needs (primarily, a
software-controlled timer and a single UART channel).

As a bonus we also both had experience with the STM32 lineup from earlier projects.

For our downloader unit we used the ESP32 micro-controller, because it has a relatively large developer community,
plenty of resources, and a built-in Wi-Fi transceiver. Cost was also a far smaller problem here, since we need much
smaller quantities of these. ST also has a few Wi-Fi-capable chips, but they are all marked Not Recommended for New
Designs.

*** Programming Languages

We used Rust to program the Node MCUs. This was both because of Rust's improved safety features over C (such as pointers
with limited lifetimes, and move semantics), as well as the improved type system.

For example, the support for tagged unions (also known as algebraic data types or sum types) allowed us to represent our
PicoTalk state machines without needing either a lot of repeated states (~Blah1~, ~Blah2~, ~Blah3~), or manually reinterpreting
variables depending on the current state.

We used C for programming the downloader, because the ESP32 MCU is based on the rather uncommon Xtensa architecture, which
LLVM (used by the Rust compiler) does not support. This wasn't as much of a hindrance, since the downloader is mostly responsible
for relaying messages between the server and the connected node.

The website was developed using Scala for both the front- and back end. This was very useful to keep the code bases consistent, and
helped avoid of code repetition when defining view models, for example. In theory it would also have been nice to stay consistent
with the MCUs, but because of the resource constraints we wouldn't have been able to share as much code anyway.

*** PCB design

We started out prototyping using solder-less breadboards and jumper cables, so that we would have more flexibility when changing
plans. However, since our MCUs are SMD-based we still had to mill our breakout boards. We also designed a "debug" board for
the STM32F030C8T6, with the same pinout as the STM32F030F4P6 that we were using as our design target.

Once we were happy with our design we made a more formal design in our CAD program KiCad. Finally we milled our PCBs using our
lab's LPKF ProtoMat mill.

* Result

All source code and design files are available at [[https://github.com/PicoNodes/PicoNodes]].

** TODO Architecture

Nodes communicate

#+BEGIN_SRC ditaa :file Report-architecture.svg :cmdline --svg
                                   +-----------------------------+
                                   | IDE                         |
                                   |                             |
                                   |                             |
                                   |                             |
                                   |                             |
                                   +-------------+---------------+
                                                 |
                                                 | PicoIDEProto (Websocket)
                                                 |
                                                 v
                                   +-----------------------------+
                                   | Server                      |
                                   |                             |
                                   |                             |
                                   |                             |
                                   |                             |
                                   +-------------+---------------+
                                                 |
                                                 | PicoStorm (TLS/WiFi)
                                                 |
                                                 v
                                          +-----+---------+
                                          | Downloader    |
                                          | +-----------+ |
                                          | |ESP32      | |
                                          | +-----------+ |
                                          +------+--------+
                                                 |
                                                 | PicoStorm (UART)
                                                 |
           +-------------------------------------+-------------------------------------+
           |                                     |                                     |
           v                                     v                                     v
  +-+-----------------+               +-------------------+               +-------------------------+
  | Compute Node      |   PicoTalk    | Compute Node      |   PicoTalk    | Peripheral Node         |
  | +---------------+ +<------------->+ +---------------+ +<------------->+ +---------------------+ |
  | |STM32F030F4P6  | |               | |STM32F030F4P6  | |               | |???                  | |
  | +---------------+ |               | +---------------+ |               | +-----------------+---+ |
  +-------------------+               +-------------------+               +-------------------------+
#+END_SRC

#+CAPTION: The PicoNodes communication architecture
#+LABEL: fig:architecture
#+RESULTS:
[[file:Report-architecture.svg]]

** Communication
   :PROPERTIES:
   :CUSTOM_ID: comm
   :END:

We decided to use a mesh interconnect (see Figure [[fig:mesh-grid]]), where each node is connected
to its direct neighbors. This is relatively simple to route, has no chance of collisions, and
# Explain absolute vs relative addressing in background?
requires no form of absolute addressing.

#+BEGIN_SRC ditaa :file Report-comm-layout.svg :cmdline --svg
  +-------------*-------------+        +-------------*-------------+        +-------------*-------------+
  |             Up            |        |             Up            |        |             Up            |
  |                           |        |                           |        |                           |
  |       **PicoNode 1**      |        |       **PicoNode 2**      |        |       **PicoNode 3**      |
  *Left                  Right*<------>*Left                  Right*<------>*Left                  Right*
  |                           |        |                           |        |                           |
  |                           |        |                           |        |                           |
  |            Down           |        |            Down           |        |            Down           |
  +-------------*-------------+        +-------------*-------------+        +-------------*-------------+
                ^                                    ^                                    ^
                |                                    |                                    |
                |                                    |                                    |
                |                                    |                                    |
                v                                    v                                    v
  +-------------*-------------+        +-------------*-------------+        +-------------*-------------+
  |             Up            |        |             Up            |        |             Up            |
  |                           |        |                           |        |                           |
  |       **PicoNode 4**      |        |       **PicoNode 5**      |        |       **PicoNode 6**      |
  *Left                  Right*<------>*Left                  Right*<------>*Left                  Right*
  |                           |        |                           |        |                           |
  |                           |        |                           |        |                           |
  |            Down           |        |            Down           |        |            Down           |
  +-------------*-------------+        +-------------*-------------+        +-------------*-------------+
                ^                                    ^                                    ^
                |                                    |                                    |
                |                                    |                                    |
                |                                    |                                    |
                v                                    v                                    v
  +-------------*-------------+        +-------------*-------------+        +-------------*-------------+
  |             Up            |        |             Up            |        |             Up            |
  |                           |        |                           |        |                           |
  |       **PicoNode 7**      |        |       **PicoNode 8**      |        |       **PicoNode 9**      |
  *Left                  Right*<------>*Left                  Right*<------>*Left                  Right*
  |                           |        |                           |        |                           |
  |                           |        |                           |        |                           |
  |            Down           |        |            Down           |        |            Down           |
  +-------------*-------------+        +-------------*-------------+        +-------------*-------------+
#+END_SRC

#+CAPTION: The PicoNode 2D mesh layout
#+LABEL: fig:mesh-grid
#+RESULTS:
[[file:Report-comm-layout.svg]]

*** PicoTalk
    :PROPERTIES:
    :CUSTOM_ID: picotalk
    :END:

The Nodes communicate using a custom asynchronous single-wire protocol called PicoTalk. We did this because we wanted to use a
mesh interconnect instead of a shared bus, and because we didn't have the hardware support or pin count to connect each pair
using a more common protocol, such as UART. It is /not/ a master/slave protocol, the transmitter/receiver roles are negotiated
for each message.

Because it is asynchronous, each side must provide its own clock. The clocks must be calibrated to 10kHz. The clocks are also
reset for each message, in order to avoid clock skew corruption.

The communication line is held high while idle by a 4.7KΩ pull-up resistor on the motherboard. Thus all participants should be configured in
open drain mode, with their internal pull-ups disabled.

PicoTalk can be divided into four primary stages, as shown in Figure [[fig:picotalk-diagram]]: Idle, Handshake, Preamble, and Message.

In the Idle stage neither party is trying to transmit anything. When a party wants to transmit they enter the Handshake stage,
by transmitting two low ticks. They then wait for a single low tick in response. If no response is heard after three ticks then
the transmitter restarts the Handshake stage. The preamble stage is 5 ticks of alternating high and low signals. This is used to
ensure that the clocks are calibrated correctly. Afterwards the message (a single byte) is sent, least significant bit first.
The bus then returns to the Idle stage.

  #+BEGIN_SRC plantuml :file Report-PicoTalk-timing.svg
    concise "Status" as Status
    concise "Transmitter" as TX
    concise "Receiver" as RX

    Status is Idle
    TX is 1
    RX is 1

    @0

    @+1
    Status is "Failing handshake (no RX)"
    TX is 0

    @+2
    TX is 1

    @+3
    Status is Handshake
    TX is 0

    @+2
    TX is 1

    @+1
    RX is 0

    @+1
    Status is "Waiting for Preamble"
    RX is 1

    @+2
    Status is Preamble
    TX is 1

    @+1
    TX is 0

    @+1
    TX is 1

    @+1
    TX is 0

    @+1
    TX is 1

    @+1
    Status is Message
    TX is "M[0]"
    @+1
    TX is "M[1]"
    @+1
    TX is "M[2]"
    @+1
    TX is "M[3]"
    @+1
    TX is "M[4]"
    @+1
    TX is "M[5]"
    @+1
    TX is "M[6]"
    @+1
    TX is "M[7]"

    @+1
    Status is Idle
    TX is 1
  #+END_SRC

  #+CAPTION: The stages of PicoTalk
  #+NAME: fig:picotalk-diagram
  #+RESULTS:
  [[file:Report-PicoTalk-timing.svg]]

** Node Design

There are a few design elements that are common to all nodes, to ensure that they can all be placed in any position
on the motherboard, and so that they can all be debugged using the same tools.

Using the LED node (Figure [[fig:led-node-pcb-front]]) as an example, they all share the following features:

#+CAPTION: The front side of the LED Node PCB
#+LABEL: fig:led-node-pcb-front
#+ATTR_LATEX: :width 4cm
[[./led-node-pcb-front.png]]

- They are all 30.48x27.94mm
- The angled corner marks the correct orientation
- The grips (in the top and bottom) help you to remove the nodes from a packed motherboard
- The pins all follow this layout (from left to right):
  - Top row:
    - 3.3V power (VDD)
    - SWCLK (used for debugging only, normally NC)
    - Ground
    - SWDIO (used for debugging only, normally NC)
    - Reset (active low)
  - Bottom row:
    - Down
    - Left
    - Up
    - Right
- They are all powered by STM32F030F4P6 MCUs

** Nodes

We designed and fabricated three different Nodes: a LED display Node (see Figure [[fig:led-node-pcb-front]]), a button
input Node (see Figure [[fig:button-node-pcb-front]]), and a programmable compute Node (see Figure
[[fig:compute-node-pcb-front]]) to connect them. They are documented further in their respective appendices (see Appendix
[[#appendix-piconode-led]], [[#appendix-piconode-switch]], and [[#appendix-piconode-compute]], respectively).

# Bring them inline instead?

#+CAPTION: The front side of the button Node PCB
#+LABEL: fig:button-node-pcb-front
#+ATTR_LATEX: :width 4cm
[[./button-node-pcb-front.png]]

#+CAPTION: The front side of the compute Node PCB (the RX/TX pins are supposed to be female, but limited by the CAD software)
#+LABEL: fig:compute-node-pcb-front
#+ATTR_LATEX: :width 4cm
[[./compute-node-pcb-front.png]]

** Motherboard

We designed a motherboard based on the [[#comm][communication layout]] mentioned earlier, visualized in Figure [[fig:motherboard-pcb-front]].
It also provides power, ground, and a reset control to all the nodes.

#+CAPTION: The front side of the motherboard PCB (female connectors are not shown due to CAD software limitations)
#+LABEL: fig:motherboard-pcb-front
[[./motherboard-pcb-front.png]]

** PicoASM

We designed a simple assembler dialect, based on Shenzhen I/O's assembler language\cite{ShenzhenIO}. It is documented
in further detail in Appendix [[#appendix-piconode-compute]]. Contrary to typical x86 desktop processors it does not have
any jump or branch instructions. Instead any instruction can be associated with a conditional flag, which is set by
our test instructions. An example PicoASM program is given in Listing [[lst:picoasm-prng]], which acts as a simple "wheel
of fortune", given a Button Node on the left side, and a LED Node on the right side.

#+CAPTION: An example PicoASM program: a "wheel of fortune" that spins while an input greater than zero is given
#+LABEL: lst:picoasm-prng
#+BEGIN_SRC text
  tcp left 0
+ mov acc right
+ teq acc 4
+ mov 1 acc
- add 1
#+END_SRC

** PicoIDE

We provided a web-based editor called PicoIDE, which allows you to edit programs and upload them to Compute nodes. It
be seen in Figure [[fig:picoide-screenshot]]. It is intended that this runs on a server on the same network as the
Downloaders.

#+CAPTION: A screenshot of PicoIDE, with a few saved files and showing the program in Listing [[lst:picoasm-prng]]
#+LABEL: fig:picoide-screenshot
[[./picoide-screenshot.png]]

*** Security

Downloaders communication is encrypted using TLS, with verification of client and server certificates. Browser
communication is not encrypted by default, but it is recommended that this is done using a reverse proxy, such
as Nginx. There is currently no user authentication system.

* Analysis

During the project we have developed an educational platform, with the aim that the platform can be used by teachers to late primary school to teach programming.

We also wanted to get an evaluation of the prototype, from surveys and observation in different schools. A prototype was developed, with some time left for an evaluation.
However, the teachers' lack of interest and time constraints were limiting factors. In the end, one teacher offered to try out PicoNodes. The evaluation went better
than we had anticipated; most of the students were motivated by PicoNodes, and wanted to learn more programming afterwards.

** Evaluation Of The Final Product

To motivate students, the prototype is designed to be very simple, with little end user setup required. We designed it to be easy to get started, but with the opportunity
to develop challenging tasks for more advanced students to practice with.

We had designed a few exercises, but due to various misunderstandings we weren't able to test them. We had planned to let 2-4 students test it in pairs, but
due to time constraints we only had 1 kit ready, while 8 students showed up. This meant that we had to improvise, and they ended up passing the kit around the table, while
the others were either observing or preparing their own programs on their tablets.

** Development Issues

Some miscalculations where made during the development process.

*** PicoTalk Timing

For example, our original PicoTalk implementation had severe
clock skew issues, where the transmitter and receiver would start synchronized, but slowly go out of sync during the message.
To solve this we ended up requiring the receiver to re-synchronize their internal clock for each message (see also Chapter
[[#picotalk]]). This also limited the speeds that the nodes could communicate at. Another way to solve this could have been a
shared clock bus, equalizing clock skew between the nodes. However, that would have led to a higher \ac{BOM} cost, and a more
complicated \ac{PCB} design. Also, we liked having an uneven number of pins, since that also acted as a guide to orient the Node
correctly in its socket.

*** Conflicting special-use pins

Another issue was that the downloader refused to boot when connected to more than 2 Nodes. At first we thought this was a power issue
(see Chapter [[#power_usage]]), but this didn't solve the issue. Instead, it turns out that the ESP32 pin we had used to control node reset
was used to detect the logic voltage level, expecting a low input for \SI{3.3}{\V} logic. Since this is the default it has a pull-down
resistor. At the same time, the node reset is active-low, and so has a built-in pull-up resistor so that device is usable when the pin
is floating. When more than 2 Nodes were connected the pull-ups would overpower the ESP32's pull-down. To fix this we attached a stronger
pull-down to the pin, which the ESP would easily overpower once running, and activate the Nodes.

*** Power Usage
    :PROPERTIES:
    :CUSTOM_ID: power_usage
    :END:

We had also miscalculated the power usage of the setup. Initially we relied on the Huzzah32's built-in voltage regulator. However,
that voltage regulator (AP2112) is only specified for loads below \SI{600}{\mA}. After recalculating our worst-case estimates we realized that
our total load is described by Equations [[eqn:power-consumption-symbolic-n-pullups]] through [[eqn:power-consumption-symbolic-i-total]]. In
these formulas, \(W_{node}\) is the number of Node columns, \(H_{node}\) is the number of Node rows, \(I_{node}\) is the maximum current
draw of each Node, \(I_{downloader}\) is the maximum current draw of the Downloader, and \(R_{pullup}\) is the resistance of the PicoTalk
pull-up resistors.

#+LABEL: eqn:power-consumption-symbolic-n-pullups
\begin{equation}
N_{pullups} = W_{node} * H_{node} * 2 + W_{node} + H_{node}
\end{equation}

#+LABEL: eqn:power-consumption-symbolic-i-pullups
\begin{equation}
I_{pullups} = \frac{U}{R_{pullup}} * N_{pullups}
\end{equation}

#+LABEL: eqn:power-consumption-symbolic-i-nodes
\begin{equation}
I_{nodes} = W_{node} * H_{node} * I_{node}
\end{equation}

#+LABEL: eqn:power-consumption-symbolic-i-board
\begin{equation}
I_{board} = I_{pullups} + I_{nodes}
\end{equation}

#+LABEL: eqn:power-consumption-symbolic-i-total
\begin{equation}
I_{total} = I_{board} + I_{downloader}
\end{equation}

Plugging in our numbers, this gives us a board power usage of \SI{1.1}{\A}, and a total power usage of \SI{1.6}{\A}. Once we had realized
how far out of spec this was, we set up a separate voltage regulator. However, since we discovered this after we had already made our motherboard,
we also made a mezzanine board with the voltage regulation logic.

** Node Selection

Another problem we had was defining what Nodes to make. We obviously needed a programmable Node, but we also wanted some way to let the user affect the computation,
and to let them see the result.

At first we wanted to make a digit display node, similar to a Lixie display\cite{Lixie}. However, due to both space and time constraints we ended up making a simplified
4-LED Node instead.

* Further Opportunities
  :PROPERTIES:
  :CUSTOM_ID: further_opportunities
  :END:

** More Nodes

The possibilities with this product is restricted to your imagination. Nodes can be developed
for special visual effects, or for specific purposes such as games or exercises. One request
we got was a TNT Node, and LEDs on the Compute Node that light while communicating. LEDs in the
communication stream was something we had already thought of, but the idea was dropped at the time
due to a lack of \ac{IO} pins.

** More Exercises

Another area of interest would be to create more exercises. It could also be interesting to have
LEGO-style tutorials for building specific projects.

** User Management

The current approach of letting everyone access everything might get chaotic in a classroom environment.
Instead, files and downloaders should be linked to specific users.

** Studies

It would be useful to have a more in-depth study of the platform's efficacy.

** Compliance

Before the product is taken to market it must be tested with the regards to the relevant compliance standards, such as CE, RoHS, UL, and FCC.
There should also be a formal security audit.

#+LATEX: \appendix

* TODO PicoNode-Compute manual
  :PROPERTIES:
  :CUSTOM_ID: appendix-piconode-compute
  :END:

* TODO PicoNode-Switch manual
  :PROPERTIES:
  :CUSTOM_ID: appendix-piconode-switch
  :END:

* TODO PicoNode-LED manual
  :PROPERTIES:
  :CUSTOM_ID: appendix-piconode-led
  :END:

\printbibliography
